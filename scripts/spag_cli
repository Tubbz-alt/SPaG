#! /usr/bin/env python
"""A Python CLI script for scanner/parser generation using SPaG.

This script deals with all the file I/O including the definition of the input
file specification. It also properly handles the dynamic importing required
for the generator(s) of interest.
"""
from argparse import ArgumentParser, Action
from configparser import RawConfigParser
from os.path import isfile
from sys import stdout
from time import time
from spag.generators import __all__ as languages
from spag.parser import ContextFreeGrammar
from spag.scanner import RegularGrammar

class DynamicGeneratorImport(Action):
    """Dynamically import the generator(s) required for source output."""

    def __call__(self, parser, namespace, values, option_string=None):
        generators = []
        for language in values:
            cls = language.capitalize()
            module = __import__('spag.generators.'+language, fromlist=[cls])
            generator = getattr(module, cls)
            generators.append(generator)
        setattr(namespace, self.dest, generators)

class CollectSpecifications(Action):
    """Collect the specification for a scanner or parser from an INI file."""

    def __call__(self, parser, namespace, values, option_string=None):
        specifications = []
        for file_specification in values:
            specification = RawConfigParser()
            specification.readfp(file_specification)

            if len(specification.sections()) != 1:
                raise ValueError('Invalid specification format - name')

            language = specification.sections()[0]
            rules = [(_id, str(rule))
                     for _id, rule in specification.items(language)]

            specifications.append({'name': language, 'rules': rules})

        setattr(namespace, self.dest, specifications)

CLI = ArgumentParser(
    prog='SPaG-CLI',
    usage='$ spag_cli --help',
    description='''
    A simple CLI (Command Line Interface) script which reads some input file
    specification(s) to generate lexers and/or parsers for a given set of
    output languages with the use of SPaG.
    ''',
    epilog='''
    For more information on SPaG, it capabilities, limitation, and more, as well
    as numerous input file examples for scanners and parsers see the README.md
    and examples/ directory located in the github repository here:
    https://github.com/rrozansk/SPaG
    '''
)

CLI.add_argument('-e', '--encoding', type=str, default='direct',
                 choices=('table', 'direct'),
                 help='encoding to use for the generated output')
CLI.add_argument('-f', '--force', action='store_true',
                 help='overwrite output file(s) if already present')
CLI.add_argument('-g', '--generate', type=str, nargs='*', default=[],
                 choices=languages, action=DynamicGeneratorImport,
                 help='target language(s) for code generation')
CLI.add_argument('-o', '--output', action='store', type=str, default='out',
                 metavar='base-filename',
                 help='base filename to use for generated output')
CLI.add_argument('-p', '--parser', type=open, action=CollectSpecifications,
                 default=[], nargs='*', metavar='specification',
                 help='file(s) containing parser name and LL(1) BNF grammar')
CLI.add_argument('-s', '--scanner', type=open, action=CollectSpecifications,
                 default=[], nargs='*', metavar='specification',
                 help='file(s) containing scanner name and type/token pairs')
CLI.add_argument('-t', '--time', action='store_true',
                 help='display the wall time taken for each component')
CLI.add_argument('-v', '--verbose', action='store_true',
                 help='output more information when running')
CLI.add_argument('-V', '--version', action='version',
                 version='SPaG-CLI v1.0.0a0',
                 help='show version information and exit')

try:
    ARGS = vars(CLI.parse_args())
    START, END = None, None

    SCANNERS = []
    for scanner in ARGS['scanner']:
        if ARGS['verbose']:
            stdout.write('Compiling {0} scanner specification...'.format(scanner['name']))
            stdout.flush()
        START = time()
        SCANNERS.append(RegularGrammar(scanner['name'], dict(scanner['rules'])))
        END = time()
        if ARGS['verbose']:
            stdout.write('done\n')
            stdout.flush()
        if ARGS['time']:
            stdout.write('Elapsed time ({0} scanner): {1}s\n'.format(scanner['name'],
                                                                     END-START))
            stdout.flush()

    PARSERS = []
    for parser in ARGS['parser']:
        if ARGS['verbose']:
            stdout.write('Compiling {0} parser specification...'.format(parser['name']))
            stdout.flush()
        START = time()
        PRODUCTIONS = {ID:[rule.split() for rule in rhs.split('|')]
                       for ID, rhs in parser['rules']}
        PARSERS.append(ContextFreeGrammar(parser['name'],
                                          PRODUCTIONS,
                                          parser['rules'][0][0]))
        END = time()
        if ARGS['verbose']:
            stdout.write('done\n')
            stdout.flush()
        if ARGS['time']:
            stdout.write('Elapsed time ({0} parser): {1}s\n'.format(parser['name'],
                                                                    END-START))
            stdout.flush()

    GENERATORS = []
    for generator in ARGS['generate']:
        TARGET = generator.__name__
        GENERATOR = generator()
        GENERATOR.encoding = ARGS['encoding']
        GENERATOR.filename = ARGS['output']
        GENERATORS.append((TARGET, GENERATOR))

    # Cross product: GENERATORS x SCANNERS x PARSERS
    OUTPUT = ((generator, scanner, parser)
              for generator in GENERATORS
              for scanner in (SCANNERS or [None])
              for parser in (PARSERS or [None]))

    for (TARGET, GENERATOR), SCANNER, PARSER in OUTPUT:
        GENERATOR.parser = PARSER
        GENERATOR.scanner = SCANNER
        if SCANNER:
            TARGET = TARGET + '_' + SCANNER.name
        if PARSER:
            TARGET = TARGET + '_' + PARSER.name
        if ARGS['verbose']:
            stdout.write('Generating {0} code...'.format(TARGET))
            stdout.flush()
        START = time()
        FILES = GENERATOR.generate()
        END = time()
        if ARGS['verbose']:
            stdout.write('done\n')
            stdout.flush()
        if ARGS['time']:
            stdout.write('Elapsed time (generator: {0}) {1}s\n'.format(TARGET,
                                                                       END-START))
            stdout.flush()

        for NAME, CONTENT in FILES.items():
            if isfile(NAME) and not ARGS['force']:
                if ARGS['verbose']:
                    stdout.write('{0} already exists; not overwriting.\n'.format(NAME))
                    stdout.flush()
                continue

            with open(NAME, 'w') as FILE:
                if ARGS['verbose']:
                    stdout.write('Outputting {0} to disk...\n'.format(FILE.name))
                    stdout.flush()
                FILE.write(CONTENT)
except TypeError as exception:
    stdout.write('Invalid input type: {0}\n'.format(exception))
except ValueError as exception:
    stdout.write('Invalid input value: {0}\n'.format(exception))
except Exception as exception:
    stdout.write('Unknown exception encountered: {0}\n'.format(exception))
finally:
    stdout.flush()
    exit(0)
