#! /usr/bin/env python
"""A Python CLI script for scanner/parser generation using SPaG.

This script deals with all the file I/O including the definition of the input
file specification. It also properly handles the dynamic importing required
for the generator(s) of interest.
"""
from argparse import ArgumentParser, Action
from configparser import RawConfigParser
from json import loads
from os.path import isfile
from sys import stdout
from time import time
from spag.generators import __all__ as languages
from spag.parser import ContextFreeGrammar
from spag.scanner import RegularGrammar

class DynamicGeneratorImport(Action):
    """Dynamically import the generator(s) required for source output."""

    @staticmethod
    def gather(generator):
        """Dynamically import the generator specified."""
        cls = generator.capitalize()
        module = __import__('spag.generators.'+generator, fromlist=[cls])
        return getattr(module, cls)

    def __call__(self, parser, namespace, values, option_string=None):
        generators = []
        for language in values:
            generators.append(DynamicGeneratorImport.gather(language))
        setattr(namespace, self.dest, generators)

class CollectScannerSpecifications(Action):
    """Collect the JSON scanner specification(s) from file(s)."""

    _mapping = {
        '\\*': RegularGrammar.kleene_star(),
        '\\+': RegularGrammar.kleene_plus(),
        '\\.': RegularGrammar.concatenation(),
        '\\|': RegularGrammar.alternative(),
        '\\?': RegularGrammar.maybe(),
        '\\(': RegularGrammar.left_parenthesis(),
        '\\)': RegularGrammar.right_parenthesis(),
        '\\[': RegularGrammar.left_bracket(),
        '\\]': RegularGrammar.right_bracket(),
        '\\-': RegularGrammar.character_range(),
        '\\^': RegularGrammar.character_negation()
    }

    @staticmethod
    def collect(specification_file):
        """Collect the JSON specification from file."""
        specification = loads(specification_file.read())

        for rule in specification.get('rules', {}).values():
            for idx, char in enumerate(rule):
                rule[idx] = CollectScannerSpecifications._mapping.get(char, char)

        return {
            'name': specification.get('language', None),
            'expressions': specification.get('rules', None)
        }

    def __call__(self, parser, namespace, values, option_string=None):
        specifications = []
        for specification in values:
            specifications.append(CollectScannerSpecifications.collect(specification))
        setattr(namespace, self.dest, specifications)

class CollectParserSpecifications(Action):
    """Collect the JSON parser specification(s) from file(s)."""

    @staticmethod
    def collect(specification_file):
        """Collect the JSON specification from file."""
        specification = loads(specification_file.read())

        return {
            'name': specification.get('lanugage', None),
            'expressions': specification.get('rules', None),
            'start': specification.get('start', None)
        }

    def __call__(self, parser, namespace, values, option_string=None):
        specifications = []
        for specification in values:
            specifications.append(CollectParserSpecifications.collect(specification))
        setattr(namespace, self.dest, specifications)

class CollectConfiguration(Action):
    """Collect the configuration (i.e. command line args) for the generator."""

    @staticmethod
    def bool(string):
        """Convert a string representation of a boolean to a python boolean."""
        if string == 'True':
            return True
        if string == 'False':
            return False
        raise ValueError('invalid boolean input value')

    def __call__(self, parser, namespace, values, option_string=None):
        configuration = RawConfigParser()
        configuration.read(values)

        if not configuration.has_section('SPaG'):
            raise ValueError('missing runtime configuration section \'SPaG\'')

        for setting, value in configuration.items('SPaG'):
            if setting == 'encoding':
                value = str(value)
                if value not in ('table', 'direct'):
                    raise ValueError('invalid encoding value')
            elif setting == 'generate':
                value = [str(lang).strip() for lang in value.split(',')]
                if len(value) == 1 and not value[0]:  # Empty setting check
                    value = []
                generators = []
                for language in value:
                    if language not in languages:
                        raise ValueError('unrecognized language for generation')
                    generators.append(DynamicGeneratorImport.gather(language))
                value = generators
            elif setting in ('parsers', 'scanners'):
                value = [str(spec).strip() for spec in value.split(',')]
                if len(value) == 1 and not value[0]:  # Empty setting check
                    value = []
                specifications = []
                for specification in value:
                    if not isfile(specification):
                        raise ValueError('input specification must be a file location')
                    with open(specification) as input_specification:
                        if setting == 'parsers':
                            specifications.append(CollectParserSpecifications.collect(input_specification))
                        elif setting == 'scanners':
                            specifications.append(CollectScannerSpecifications.collect(input_specification))
                value = specifications
            elif setting in ('force', 'time', 'verbose'):
                value = CollectConfiguration.bool(str(value))
            elif setting in ('configuration', 'output'):
                value = str(value)
            else:
                raise ValueError('unrecognized option: {0}'.format(setting))

            setattr(namespace, setting, value)

class GenerateConfiguration(Action):
    """Generate the configuration file for the generator."""

    def __call__(self, parser, namespace, values, option_string=None):
        with open(values, 'w') as rcfile:
            rcfile.write('''[SPaG]

# Path to the runtime configuration file.
# NOTE: Ignored and only present to mirror the command line option.
configuration={0}

# Choose the scanner/parser source encoding method. options include: 'table'
# or 'direct'.
encoding=direct

# Overwrite pre-exisintg files if they exist. Possible values include 'True' or
# 'False'.
force=True

# List any language(s) targeted for generation.
generate=c,
         go,
         python

# Base filename to derive the generated output filename(s).
output=out

# File path(s) to the JSON parser specification(s), if any.
# The file should contain a dictionary with keys:
#   - language (str): BNF grammar name.
#   - rules (dict[str]list[list[str]]): Map [non]terminals to list of rules.
#   - start (str): nonterminal start rule.
parsers=examples/INI/parser.json,
        examples/JSON/parser.json,
        examples/Lisp/parser.json

# File path(s) to the JSON scanner specification(s), if any.
# The file should contain a dictionary with keys:
#   - language (str): Regular grammar name.
#   - rules (dict[str]list[str]): Map tokens to sequences.
scanners=examples/INI/scanner.json,
         examples/JSON/scanner.json,
         examples/Lisp/scanner.json

# Time the various components and report it. Possible values include 'True' or
# 'False'.
time=True

# Output extra messages when run. Possible values include 'True' or 'False'.
verbose=True
'''.format(values))
        exit(0)

CLI = ArgumentParser(
    prog='SPaG-CLI',
    usage='$ spag_cli --help',
    description='''
    A simple CLI (Command Line Interface) script which reads input file
    specification(s) to generate lexers and/or parsers for a given set of
    output languages with the use of the SPaG framework.
    ''',
    epilog='''
    As noted above it is possible to supply any number of scanners, parsers, and
    generators. This allows easy generation of any number of specifications for
    as many output languages desired. Simply stated this CLI script drives the
    genration of the cross product of LANGUAGES x SCANNERS x PARSERS. Also note
    it is possible to override configuration file defaults with command line
    flags as long as the flags are passed after the configuration file option.
    For more information on SPaG, it capabilities, limitation, and more, as well
    as numerous input file examples for scanners and parsers see the README.md
    and examples/ directory located in the github repository here:
    https://github.com/rrozansk/SPaG
    '''
)

CLI.add_argument('-c', '--configuration', type=open, metavar='rcfile',
                 action=CollectConfiguration,
                 help='Collect arguments from rcfile instead of command line.')
CLI.add_argument('-e', '--encoding', type=str, default='direct',
                 choices=('table', 'direct'),
                 help='Source program encoding to use for the generated output.')
CLI.add_argument('-f', '--force', action='store_true',
                 help='Overwrite pre-exisitng output file(s).')
CLI.add_argument('-g', '--generate', type=str, nargs='*', default=[],
                 choices=languages, action=DynamicGeneratorImport,
                 help='Target language(s) for code generation.')
CLI.add_argument('--generate-rcfile', action=GenerateConfiguration, nargs='?',
                 default='.spagrc', const='.spagrc', metavar='rcfile',
                 help='Generate an rcfile and exit; .spagrc if not specified.')
CLI.add_argument('-o', '--output', action='store', type=str, default='out',
                 metavar='base-filename',
                 help='Base-filename to derive generated output filename(s).')
CLI.add_argument('-p', '--parsers', type=open, action=CollectParserSpecifications,
                 default=[], nargs='*', metavar='filepath',
                 help='File path(s) to the JSON parser specification(s). '
                      'The file should contain a JSON dictionary with keys: '
                      '\'language\' (str), \'rules\' '
                      '(dict[str]list[list[str]]), and \'start\' (str). The '
                      'first represents the BNF grammar\'s name. The second '
                      'represents a mapping of [non]terminals to a a list of '
                      'rules, with [] representing epsilon. The third '
                      'represents the nonterminal start rule fo the grammar.')
CLI.add_argument('-s', '--scanners', type=open, action=CollectScannerSpecifications,
                 default=[], nargs='*', metavar='filepath',
                 help='File path(s) to the JSON scanner specification(s). '
                      'The file should contain a JSON dictionary with keys: '
                      '\'language\' (str), and \'rules\' (dict[str]list[str]). '
                      'The first represents the regular grammar\'s name. The '
                      'second represents a mapping of token names to a '
                      'sequence representing the expression. The strings in '
                      'the sequence should be of length one unless excaping an '
                      'operator (*,+,.,|,?,(,),[,],-,^).')
CLI.add_argument('-t', '--time', action='store_true',
                 help='Display the wall time taken for each component.')
CLI.add_argument('-v', '--verbose', action='store_true',
                 help='Output more information when running.')
CLI.add_argument('-V', '--version', action='version',
                 version='SPaG-CLI v1.0.0a0',
                 help='Show version information and exit.')

try:
    ARGS = vars(CLI.parse_args())
    START, END = None, None

    SCANNERS = []
    for scanner in ARGS['scanners']:
        if ARGS['verbose']:
            stdout.write('Compiling {0} scanner specification...'.format(scanner['name']))
            stdout.flush()
        START = time()
        SCANNERS.append(RegularGrammar(**scanner))
        END = time()
        if ARGS['verbose']:
            stdout.write('done\n')
            stdout.flush()
        if ARGS['time']:
            stdout.write('Elapsed time ({0} scanner): {1}s\n'.format(scanner['name'],
                                                                     END-START))
            stdout.flush()

    PARSERS = []
    for parser in ARGS['parsers']:
        if ARGS['verbose']:
            stdout.write('Compiling {0} parser specification...'.format(parser['name']))
            stdout.flush()
        START = time()
        PARSERS.append(ContextFreeGrammar(**parser))
        END = time()
        if ARGS['verbose']:
            stdout.write('done\n')
            stdout.flush()
        if ARGS['time']:
            stdout.write('Elapsed time ({0} parser): {1}s\n'.format(parser['name'],
                                                                    END-START))
            stdout.flush()

    GENERATORS = []
    for generator in ARGS['generate']:
        TARGET = generator.__name__
        GENERATOR = generator()
        GENERATOR.encoding = ARGS['encoding']
        GENERATOR.filename = ARGS['output']
        GENERATORS.append((TARGET, GENERATOR))

    # Cross product: GENERATORS x SCANNERS x PARSERS
    OUTPUT = ((generator, scanner, parser)
              for generator in GENERATORS
              for scanner in (SCANNERS or [None])
              for parser in (PARSERS or [None]))

    for (TARGET, GENERATOR), SCANNER, PARSER in OUTPUT:
        GENERATOR.parser = PARSER
        GENERATOR.scanner = SCANNER
        if SCANNER:
            TARGET = TARGET + '_' + SCANNER.name
        if PARSER:
            TARGET = TARGET + '_' + PARSER.name
        if ARGS['verbose']:
            stdout.write('Generating {0} code...'.format(TARGET))
            stdout.flush()
        START = time()
        FILES = GENERATOR.generate()
        END = time()
        if ARGS['verbose']:
            stdout.write('done\n')
            stdout.flush()
        if ARGS['time']:
            stdout.write('Elapsed time (generator: {0}) {1}s\n'.format(TARGET,
                                                                       END-START))
            stdout.flush()

        for NAME, CONTENT in FILES.items():
            if isfile(NAME) and not ARGS['force']:
                if ARGS['verbose']:
                    stdout.write('{0} already exists; not overwriting.\n'.format(NAME))
                    stdout.flush()
                continue

            with open(NAME, 'w') as FILE:
                if ARGS['verbose']:
                    stdout.write('Outputting {0} to disk...\n'.format(FILE.name))
                    stdout.flush()
                FILE.write(CONTENT)
except TypeError as exception:
    stdout.write('Invalid input type:\n{0}\n'.format(exception))
except ValueError as exception:
    stdout.write('Invalid input value:\n{0}\n'.format(exception))
except Exception as exception:
    stdout.write('Unknown exception encountered:\n{0}\n'.format(exception))
finally:
    stdout.flush()
    exit(0)
